[{"title":"0.解构基本pipeline","url":"/2024/04/07/0.%20%E8%A7%A3%E6%9E%84%E5%9F%BA%E6%9C%ACpipeline/","content":"解构基本pipeline借助pipeline，仅需四行代码即可生成图像：\nfrom diffusers import DDPMPipelineddpm = DDPMPipeline.from_pretrained(&quot;google/ddpm-cat-256&quot;, use_safetensors=True).to(&quot;cuda&quot;)image = ddpm(num_inference_steps=25).images[0]\n\n在上面的示例中，pipeline包含：\n\n去噪模型：UNet2DModel\n采样器：DDPMScheduler\n\npipeline通过获取所需输出大小的随机噪声并将其多次通过去噪模型来对图像进行去噪。在每个时间步，去噪模型预测噪声残差，调采样器使用它来预测噪声较小的图像。管道重复此过程，直到到达指定数量的推理步骤的图像。\n要分别使用去噪模型和采样器重新创建pipeline，让我们编写自己的去噪过程：\n\n载入去噪模型和采样器：\nfrom diffusers import DDPMScheduler, UNet2DModelscheduler = DDPMScheduler.from_pretrained(&quot;google/ddpm-cat-256&quot;)model = UNet2DModel.from_pretrained(&quot;google/ddpm-cat-256&quot;, use_safetensors=True).to(&quot;cuda&quot;)\n\n通过采样器设置去噪过程的时间步数：\nscheduler.set_timesteps(50)\n\n设置采样器的时间步数会创建一个包含均匀间隔元素的张量，在本示例中为 50。每个元素对应于模型对图像进行去噪的时间步。在进行去噪循环时，将迭代该张量以对图像进行去噪：\nscheduler.timestepstensor([980, 960, 940, 920, 900, 880, 860, 840, 820, 800, 780, 760, 740, 720,    \t700, 680, 660, 640, 620, 600, 580, 560, 540, 520, 500, 480, 460, 440,    \t420, 400, 380, 360, 340, 320, 300, 280, 260, 240, 220, 200, 180, 160,    \t140, 120, 100,  80,  60,  40,  20,   0])\n\n创建与所需输出图像形状相同的随机噪声：\nimport torchsample_size = model.config.sample_sizenoise = torch.randn((1, 3, sample_size, sample_size), device=&quot;cuda&quot;)\n\n现在编写一个循环来迭代。\n\n在每个时间步，都会执行 UNet2DModel.forward() ，根据输入的噪声图像(input)和时间步(t)返回噪声残差(noisy_residual)。\n采样器的 step() 方法利用噪声残差(noisy_residual)、时间步(t))和噪声图像(input)预测前一个时间步长的图像。该输出成为去噪循环的下一个输入。\n\ninput = noisefor t in scheduler.timesteps:    with torch.no_grad():        noisy_residual = model(input, t).sample    previous_noisy_sample = scheduler.step(noisy_residual, t, input).prev_sample    input = previous_noisy_sample\n\n最后一步是将去噪输出转换为图像：\nfrom PIL import Imageimport numpy as np# input的数据范围为[-1, 1], 转为[0, 1]# shape: [1, 3, sample_size, sample_size] -&gt; [3, sample_size, sample_size]image = (input / 2 + 0.5).clamp(0, 1).squeeze()# shape: [3, sample_size, sample_size] -&gt; [sample_size, sample_size, 3]# data range: (float32)[0, 1] -&gt; (uint8)[0, 255]# device: cuda -&gt; cpu# type: torch.tensor -&gt; numpy.arrayimage = (image.permute(1, 2, 0) * 255).round().to(torch.uint8).cpu().numpy()# 输出为图像image = Image.fromarray(image)image\n\n","categories":["Research"],"tags":["diffusers","AIGC"]},{"title":"1.解构Stable Diffusion","url":"/2024/03/14/1.%20%E8%A7%A3%E6%9E%84%20Stable%20Diffusion/","content":"解构Stable DiffusionStable Diffusion是一种文本到图像的潜在扩散模型（LDM）。它使用图像的低维表示而不是实际的像素空间，这使得它的内存效率更高。\n\nVAE编码器将图像压缩为低维表示，VAE解码器将压缩的低维表示转换回图像。\n\n对于文本到图像模型，需要一个分词器（tokenizer）和一个文本编码器（text encoder）来生成文本嵌入（text embeddings）。\n\n\n如上所述，SD pipeline比仅包含 UNet 模型的 DDPM pipeline更复杂。Stable Diffusion具有三个独立的预训练模型。\n\n运作机制：Stable Diffusion with 🧨 Diffusers (huggingface.co)\n\n\nThe autoencoder (VAE): AutoencoderKL\nThe U-Net: UNet2DConditionModel\nThe Text-encoder: CLIPTextModel\n\nSD pipeline 运作机制载入所有组件使用 from_pretrained() 方法加载所有组件。可以在预训练的 runwayml&#x2F;stable-diffusion-v1-5 中找到它们，每个组件都存储在单独的子文件夹中：\nfrom PIL import Imageimport torchfrom transformers import CLIPTextModel, CLIPTokenizerfrom diffusers import AutoencoderKL, UNet2DConditionModel, PNDMScheduler# 自编码器，使用fp16半精度权重vae = AutoencoderKL.from_pretrained(&quot;sd-v1.5&quot;, subfolder=&quot;vae&quot;, variant=&#x27;fp16&#x27;, use_safetensors=True)# 分词器tokenizer = CLIPTokenizer.from_pretrained(&quot;sd-v1.5&quot;, subfolder=&quot;tokenizer&quot;)# 文本编码器，使用fp16半精度权重text_encoder = CLIPTextModel.from_pretrained(&quot;sd-v1.5&quot;, subfolder=&quot;text_encoder&quot;, variant=&#x27;fp16&#x27;, use_safetensors=True)# 去噪器Unet，使用fp16半精度权重unet = UNet2DConditionModel.from_pretrained(&quot;sd-v1.5&quot;, subfolder=&quot;unet&quot;, variant=&#x27;fp16&#x27;, use_safetensors=True)\n\n将采样器替换为 UniPCMultistepScheduler，而不是 sd1.5 默认的 PNDMScheduler，通过以下代码实现：\nfrom diffusers import UniPCMultistepScheduler# 采样器，修改为UniPCMultistepScheduler 而不是默认的PNDMSchedulerscheduler = UniPCMultistepScheduler.from_pretrained(&quot;sd-v1.5&quot;, subfolder=&quot;scheduler&quot;)\n\n为了加速推理，将具有可训练权重的模型移至 GPU：\ntorch_device = torch.device(&quot;cuda&quot;)vae.to(torch_device)text_encoder.to(torch_device)unet.to(torch_device)\n\n\n\n创建文本嵌入对文本进行标记以生成文本嵌入。该文本用于为 UNet 模型输入文本条件，在扩散过程中引导生成内容。\n\nguidance_scale: 该参数决定生成图像时应给予文本提示的权重，即文本引导的强度\n\n随意选择你喜欢的任何文本提示！设定基本参数如下：\nprompt = [&quot;a photograph of an astronaut riding a horse&quot;]batch_size = len(prompt)          # 生成的批量大小height = 512                      # 目标生成的图像的高width = 512                       # 目标生成的图像的宽num_inference_steps = 25          # 去噪总步数guidance_scale = 7.5              # classifier-free guidance 条件引导强度generator = torch.manual_seed(0)  # 用于生成随机噪声的随机数种子\n\n使用分词器（tokenizer）对文本进行标记并生成嵌入：\n# 分词text_input = tokenizer(    prompt,                                # 文本    padding=&quot;max_length&quot;,                  # 填充文本以达到最大长度    max_length=tokenizer.model_max_length, # 设置了文本分词的最大长度 max_length = 77    truncation=True,                       # 如果文本超过最大长度，将截断它。    return_tensors=&quot;pt&quot;                    # 表示返回 PyTorch 张量格式的结果。).to(torch_device)# 将分词结果转为文本嵌入with torch.no_grad():    text_embeddings = text_encoder(text_input.input_ids)[0]\n\n部分变量细节：\ntext_input:&lt;class &#x27;transformers.tokenization_utils_base.BatchEncoding&#x27;&gt;text_input.input_ids:  - type: &lt;class &#x27;torch.Tensor&#x27;&gt;  - shape: torch.Size([1, 77]) [batch, max_length]  - dtype: torch.int64  - device: cuda:0    text_embeddings:  - &lt;class &#x27;torch.Tensor&#x27;&gt;  - torch.Size([1, 77, 768])  - torch.float32  - cuda:0\n\n接下来还需要生成无条件文本嵌入，即填充标记的嵌入。这些需要与条件 text_embeddings 具有相同的形状（batch_size 和 seq_length）：\nmax_length = text_input.input_ids.shape[-1] # 77# 用空文本获取idsuncond_input = tokenizer(    [&quot;&quot;] * batch_size,     padding=&quot;max_length&quot;,     max_length=max_length,     return_tensors=&quot;pt&quot;)uncond_embeddings = text_encoder(uncond_input.input_ids.to(torch_device))[0]\n\n让我们将条件嵌入和无条件嵌入连接为一个批量，以避免进行两次前向传递：\ntext_embeddings = torch.cat([uncond_embeddings, text_embeddings])  - &lt;class &#x27;torch.Tensor&#x27;&gt;  - torch.Size([2, 77, 768])  - torch.float32  - cuda:0\n\n\n\n创建随机噪声接下来，生成一些初始随机噪声作为扩散过程的起点。它将逐渐去噪来生成图像的潜在表示。此时，潜在表示小于最终图像尺寸，VAE解码器后会将其转换为最终的 $512 \\times 512$ 图像。\nprint(vae.config.block_out_channels) # [128, 256, 512, 512]print(2 ** (len(vae.config.block_out_channels) - 1))VAE的层数为4，每两层之间一次下采样，下采样倍率为8\n\n生成初始噪声：\n# shape: [1, 4, 64, 64]latents = torch.randn(    (batch_size, unet.config.in_channels, height // 8, width // 8),     generator=generator                                             ).to(torch_device)\n\n\n\n对图像进行去噪首先使用 sigma（噪声缩放值）缩放初始噪声分布，这是 UniPCMultistepScheduler 等改进采样器所需的：\nlatents = latents * scheduler.init_noise_sigma# init_noise_sigma = 1.0\n\n最后一步是创建去噪循环，该循环将逐步将纯噪声转换为文本提示所描述的图像的潜在表示。去噪循环需要做三件事：\n\n设置去噪期间采样器使用的时间步长。\n\n迭代时间步。\n\n在每个时间步 $t$，调用 UNet 模型来根据 $x_t$ 预测噪声残差 $\\epsilon_t$，并将其传递给采样器以计算上一个时间步的噪声样本 $x_{t-1}$。\n from tqdm.auto import tqdm\n设定采样器的迭代步数 scheduler.set_timesteps(num_inference_steps) # 25\n迭代时间步：scheduler.timesteps- &lt;class ‘torch.Tensor’&gt;- torch.Size([25])- torch.int64- cpu for t in tqdm(scheduler.timesteps): # 如果使用CFG，为了避免进行两次前向传递，则可以在batch维度扩展输入。 latent_model_input &#x3D; torch.cat([latents] * 2) # 预测噪声前，根据时间步t缩放Unet的输入x_t latent_model_input &#x3D; scheduler.scale_model_input(latent_model_input, timestep&#x3D;t) # 预测噪声残差 with torch.no_grad():     # unet的输出类型：&lt;class ‘diffusers.models.unets.unet_2d_condition.UNet2DConditionOutput’&gt;     noise_pred &#x3D; unet(latent_model_input, t, encoder_hidden_states&#x3D;text_embeddings)     noise_pred &#x3D; noise_pred.sample     # &lt;class ‘torch.Tensor’&gt;     # torch.Size([2, 4, 64, 64])     # torch.float32     # cuda: 0 # 使用CFG计算新的噪声残差 noise_pred_uncond, noise_pred_text &#x3D; noise_pred.chunk(2) noise_pred &#x3D; noise_pred_uncond + guidance_scale * (noise_pred_text - noise_pred_uncond) # 使用采样器计算上一个时间步的样本：x_t -&gt; x_t-1 # 采样器的输出类型：&lt;class ‘diffusers.schedulers.scheduling_utils.SchedulerOutput’&gt; latents &#x3D; scheduler.step(noise_pred, t, latents) latents &#x3D; latents.prev_sample\n\n\n解码潜在表示为图像最后一步是使用 vae 将潜在表示解码为图像，并通过样本获取解码输出：\n# 在将潜在表示输入VAE解码器前进行缩放latents = 1 / 0.18215 * latentswith torch.no_grad():    # VAE解码器输出类型：&lt;class &#x27;diffusers.models.autoencoders.vae.DecoderOutput&#x27;&gt;    image = vae.decode(latents)    image = image.sample\n\n最后，将图像转换为 PIL.Image 以查看生成的图像！\n# 调整图像的范围和数据类型num = len(os.listdir(&#x27;./results&#x27;))image = (image / 2 + 0.5).clamp(0, 1).squeeze()image = (image.permute(1, 2, 0) * 255).to(torch.uint8).cpu().numpy()image = Image.fromarray(image)image.save(f&#x27;./results/learn_sp&#123;num&#125;.png&#x27;)\n\n\n\n从基本管道到复杂管道，您已经看到编写自己的扩散系统真正需要的只是一个降噪循环。该循环应设置调度程序的时间步长，对其进行迭代，并交替调用 UNet 模型来预测噪声残差，并将其传递给调度程序以计算先前的噪声样本。\n这就是Diffusers 的设计目的：让使用模型和调度程序直观、轻松地编写自己的扩散系统。\nNext:\n\nContribute a community pipeline (huggingface.co)\nPipelines (huggingface.co)\n运作机制：Stable Diffusion with 🧨 Diffusers (huggingface.co)\n\n","categories":["Research"],"tags":["diffusers","AIGC"]},{"title":"3.训练diffusion model","url":"/2024/03/09/3.%20%E8%AE%AD%E7%BB%83Diffusion%20Model/","content":"Train a diffusion model无条件图像生成是扩散模型的一种流行应用，它生成的图像与用于训练的数据集中的图像相似。通常，最好的结果是通过在特定数据集上微调预训练模型来获得的。\n您可以在 Hub 上找到许多这样的检查点，但如果您找不到您喜欢的检查点，您可以随时训练自己的检查点！\n本教程将教您如何在 Smithsonian Butterflies 数据集的子集上从头开始训练 UNet2DModel，以生成您自己的Butterflies\n\ndiffusers_training_example.ipynb - Colaboratory (google.com)\n\n训练配置为了方便起见，创建一个包含训练超参数的 TrainingConfig 类：\nfrom dataclasses import dataclass@dataclassclass TrainingConfig:    image_size = 128                       # 生成图像的分辨率    train_batch_size = 16                  # 训练batch    eval_batch_size = 16                   # 验证阶段的图像数量    num_epochs = 50    gradient_accumulation_steps = 1        #    learning_rate = 1e-4    lr_warmup_steps = 500    save_image_epochs = 10    save_model_epochs = 30    mixed_precision = &quot;fp16&quot;               # `no` for float32, `fp16` for automatic mixed precision    output_dir = &quot;ddpm-butterflies-128&quot;  # the model name locally and on the HF Hub    push_to_hub = False  # whether to upload the saved model to the HF Hub    hub_model_id = &quot;TO-Hitori/my-awesome-model&quot;  # the name of the repository to create on the HF Hub    hub_private_repo = False    overwrite_output_dir = True  # overwrite the old model when re-running the notebook    seed = 0config = TrainingConfig()\n\n\n\n载入数据集您可以使用datasets库轻松加载Smithsonian Butterflies数据集：\nfrom datasets import load_dataset# 数据集路径：本地路径或hugging-face路径config.dataset_name = r&quot;D:\\MyData\\smithsonian_butterflies_subset&quot;dataset = load_dataset(config.dataset_name, split=&quot;train&quot;)\n\n\n在此查找其他数据集：huggan (HugGAN Community) (huggingface.co)\n\nDatasets 使用 Image 功能自动解码图像数据并将其加载为我们可以可视化的 PIL.Image：\nimport matplotlib.pyplot as pltfig, axs = plt.subplots(1, 4, figsize=(16, 4))for i, image in enumerate(dataset[:4][&quot;image&quot;]):    axs[i].imshow(image)    axs[i].set_axis_off()fig.show()\n\n这些图像的尺寸各不相同，因此需要先对它们进行预处理：\n\nResize 将图像大小更改为 config.image_size 中定义的大小。 \nRandomHorizontalFlip 通过随机镜像翻转图像来增强数据集。 \nNormalize对于将像素值重新缩放到 [-1, 1] 范围非常重要，这是模型所期望的输入范围。\n\nfrom torchvision import transformspreprocess = transforms.Compose(    [        transforms.Resize((config.image_size, config.image_size)),        transforms.RandomHorizontalFlip(),        transforms.ToTensor(),        transforms.Normalize([0.5], [0.5]),    ])\n\n使用Datasets的 set_transform 方法在训练期间动态应用预处理函数：\ndef transform(examples):    images = [preprocess(image.convert(&quot;RGB&quot;)) for image in examples[&quot;image&quot;]]    return &#123;&quot;images&quot;: images&#125;dataset.set_transform(transform)\n\n将数据集包装在torch的 DataLoader 中进行训练！\nimport torchtrain_dataloader = torch.utils.data.DataLoader(dataset, batch_size=config.train_batch_size, shuffle=True)\n\n\n\n创建 UNet2D 模型 Diffusers 中的预训练模型可以使用您想要的参数轻松地从其模型类创建。例如，要创建 UNet2DModel：\n# 创建U-Netfrom diffusers import UNet2DModelmodel = UNet2DModel(    sample_size=config.image_size,  # 图像分辨率    in_channels=3,                  # 输入图像的通道数量    out_channels=3,                 # 输出图像的通道数量    layers_per_block=2,             # 每层使用的残差块个数    block_out_channels=(128, 128, 256, 256, 512, 512),  # 每一层的输出通道数量    down_block_types=(        &quot;DownBlock2D&quot;,              # 残差下采样模块        &quot;DownBlock2D&quot;,        &quot;DownBlock2D&quot;,        &quot;DownBlock2D&quot;,        &quot;AttnDownBlock2D&quot;,          # 有spatial self-attention的下采样残差模块        &quot;DownBlock2D&quot;,    ),    up_block_types=(        &quot;UpBlock2D&quot;,                # 残差上采样模块        &quot;AttnUpBlock2D&quot;,            # 有spatial self-attention的上采样残差模块        &quot;UpBlock2D&quot;,        &quot;UpBlock2D&quot;,        &quot;UpBlock2D&quot;,        &quot;UpBlock2D&quot;,    ),)print(&quot;UNet2DModel have &#123;&#125; paramerters in total&quot;.format(sum(x.numel() for x in model.parameters())))# UNet2DModel have 113673219 paramerters in total\n\n检查样本图像形状与模型输出形状是否匹配：\nsample_image = dataset[0][&quot;images&quot;].unsqueeze(0)print(&quot;Input shape:&quot;, sample_image.shape)print(&quot;Output shape:&quot;, model(sample_image, timestep=0).sample.shape)&#x27;&#x27;&#x27;Input shape: torch.Size([1, 3, 128, 128])Output shape: torch.Size([1, 3, 128, 128])&#x27;&#x27;&#x27;\n\n\n\n创建采样器根据您使用模型进行训练还是推理，采样器的行为会有所不同。\n\n在推理过程中，采样器根据噪声生成图像。\n在训练期间，采样器从扩散过程中的特定点获取模型输出（或样本），并根据噪声调度noise schedule和更新规则update rule将噪声注入图像。\n\n让我们看一下 DDPMScheduler 并使用 add_noise 方法向sample_image 添加一些随机噪声：\nimport torchfrom PIL import Imagefrom diffusers import DDPMSchedulerfrom torchvision.utils import save_image, make_grid# 用总步数来初始化采样器noise_scheduler = DDPMScheduler(num_train_timesteps=1000)# 设定加噪序列，这里选择了7个依次增大的时间步timesteps = torch.LongTensor([50, 150, 250, 450, 650, 850, 990])# 时间步的数量为batch，采样图片的形状后三个维度，构建采样噪声noise = torch.randn(timesteps.shape + sample_image.shape[1:])# 利用采样器的add_noise方法将噪声注入采样图片noisy_image = noise_scheduler.add_noise(sample_image, noise, timesteps)# 保存图片观测采样器的加噪效果save_to_show = make_grid(torch.cat([sample_image, noisy_image], dim=0))save_image(save_to_show, &#x27;./test_scheduler.png&#x27;)\n\n模型的训练目标是预测添加到图像中的噪声。这一步的损失可以通过下式计算：\n# 损失函数：最简单的MSE损失函数import torch.nn.functional as Fprint(&#x27;test loss func&#x27;)noise_pred = model(noisy_image, timesteps).sampleloss = F.mse_loss(noise_pred, noise)print(&#x27;loss value = &#x27;, loss.item())\n\n\n\n训练模型到目前为止，您已经掌握了开始训练模型的大部分内容，剩下的就是将所有内容组合在一起。 首先，您需要一个优化器和一个学习率调度器：\n# 开始训练：设置调度器from diffusers.optimization import get_cosine_schedule_with_warmupoptimizer = torch.optim.AdamW(model.parameters(), lr=config.learning_rate)lr_scheduler = get_cosine_schedule_with_warmup(    optimizer=optimizer,    num_warmup_steps=config.lr_warmup_steps,    num_training_steps=(len(train_dataloader) * config.num_epochs),)\n\n然后，您需要一种评估模型的方法。为了进行评估，您可以使用 DDPMPipeline 生成一批样本图像并将其保存为网格：\nfrom diffusers import DDPMPipelinefrom diffusers.utils import make_image_gridimport osdef evaluate(config, epoch, pipeline):    # Sample some images from random noise (this is the backward diffusion process).    # The default pipeline output type is `List[PIL.Image]`    # 使用pipeline生成图像    images = pipeline(        batch_size=config.eval_batch_size,        generator=torch.manual_seed(config.seed),    ).images    # 将图像拼接为网格    image_grid = make_image_grid(images, rows=4, cols=4)    # 保存验证图像    test_dir = os.path.join(config.output_dir, &quot;samples&quot;)    os.makedirs(test_dir, exist_ok=True)    image_grid.save(f&quot;&#123;test_dir&#125;/&#123;epoch:04d&#125;.png&quot;)\n\n现在，您可以使用 Accelerate 将所有这些组件包装在一个训练循环中，以轻松进行：\n\nTensorBoard 日志记录\n梯度累积和混合精度训练。\n要将模型上传到 Hub，请编写一个函数来获取存储库名称和信息，然后将其推送到 Hub。\n\n接下来是训练核心部分：\ndef train_loop(config, model, noise_scheduler, optimizer, train_dataloader, lr_scheduler):    # 初始化 accelerator 和 tensorboard 日志记录    accelerator = Accelerator(        mixed_precision=config.mixed_precision,                          # 是否混合精度训练        gradient_accumulation_steps=config.gradient_accumulation_steps,  # 梯度累积步数        log_with=&quot;tensorboard&quot;,                                          # 使用tensorboard记录日志        project_dir=os.path.join(config.output_dir, &quot;logs&quot;),             # 日志路径    )    # 如果在主进程    if accelerator.is_main_process:        # 创建输出文件夹        if config.output_dir is not None:            os.makedirs(config.output_dir, exist_ok=True)        # 上传到HF的设置        if config.push_to_hub:            repo_id = create_repo(                repo_id=config.hub_model_id or Path(config.output_dir).name, exist_ok=True            ).repo_id        # 初始化追踪器        accelerator.init_trackers(&quot;train_example&quot;)    # 用accelerate包装：模型、优化器、数据加载器和学习率调度器    # 保证输入和输出的顺序一致即可    model, optimizer, train_dataloader, lr_scheduler = accelerator.prepare(        model, optimizer, train_dataloader, lr_scheduler    )    # 初始化全局步数    global_step = 0    # 开始训练模型    for epoch in range(config.num_epochs):        # 创建进度条        progress_bar = tqdm(total=len(train_dataloader), disable=not accelerator.is_local_main_process)        # 设置进度条描述        progress_bar.set_description(f&quot;Epoch &#123;epoch&#125;&quot;)        # 对数据加载器中的每个批次进行循环        for step, batch in enumerate(train_dataloader):            # 从数据集获取图像            clean_images = batch[&quot;images&quot;]            # 生成即将加入图像的噪声            noise = torch.randn(clean_images.shape, device=clean_images.device)            # 获取当前batch-size            bs = clean_images.shape[0]            # 为当前batch中每个图像随机采样一个时间步            timesteps = torch.randint(                0,                                          # 起点                noise_scheduler.config.num_train_timesteps, # 终点                (bs,),                                      # 形状/数量                device=clean_images.device,                dtype=torch.int64            )            # 使用采样器，根据每个时间步的噪声幅度向干净的图像添加噪声            # 这是前向扩散过程            noisy_images = noise_scheduler.add_noise(clean_images, noise, timesteps)            # 使用accelerator累积模型梯度            with accelerator.accumulate(model):                # 预测噪声残差                noise_pred = model(noisy_images, timesteps, return_dict=False)[0]                # 计算损失函数                loss = F.mse_loss(noise_pred, noise)                # 反向传播梯度                accelerator.backward(loss)                # 梯度裁剪                accelerator.clip_grad_norm_(model.parameters(), 1.0)                optimizer.step()      # 迭代优化器                lr_scheduler.step()   # 迭代学习率调度器                optimizer.zero_grad() # 清零梯度            # 更新基督徒            progress_bar.update(1)            # 记录日志：损失函数，学习率变化            logs = &#123;&quot;loss&quot;: loss.detach().item(), &quot;lr&quot;: lr_scheduler.get_last_lr()[0], &quot;step&quot;: global_step&#125;            progress_bar.set_postfix(**logs)            accelerator.log(logs, step=global_step)            # 全局步数增加            global_step += 1        # 在每个epoch后，你可以选择使用evaluate()采样一些演示图像并保存模型        if accelerator.is_main_process:            # 初始化一个pipeline，传入当前训练的模型和调度器            pipeline = DDPMPipeline(unet=accelerator.unwrap_model(model), scheduler=noise_scheduler)            # 根据验证频率保存研究结果            if (epoch + 1) % config.save_image_epochs == 0 or epoch == config.num_epochs - 1:                evaluate(config, epoch, pipeline)            if (epoch + 1) % config.save_model_epochs == 0 or epoch == config.num_epochs - 1:                if config.push_to_hub:                    upload_folder(                        repo_id=repo_id,                        folder_path=config.output_dir,                        commit_message=f&quot;Epoch &#123;epoch&#125;&quot;,                        ignore_patterns=[&quot;step_*&quot;, &quot;epoch_*&quot;],                    )                else:                    pipeline.save_pretrained(config.output_dir)train_loop(config, model, noise_scheduler, optimizer, train_dataloader, lr_scheduler)\n\n\n\n\n\n\n\n\n\n\n\n\n\nNextdiffusers_training_example.ipynb - Colaboratory (google.com)\nTextual Inversion (huggingface.co)\nDreamBooth (huggingface.co)\nText-to-image (huggingface.co)\nLoRA (huggingface.co)\n","categories":["Research"],"tags":["diffusers","AIGC"]},{"title":"conda常用命令","url":"/2021/11/25/conda%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","content":"conda常用命令在windows的cmd下使用如下指令进入conda：\nactivate\n\n环境管理创建虚拟环境：conda create -n [env_name] python=[X.X]\n\n\nenv_name：要创建的环境的名字\nX.X：要创建的环境的python的版本，如3.7\n\n激活虚拟环境conda activate [env_name]\n\n停用当前环境conda deactivate\n\n查看当前环境的python版本python --version\n\n查看所有存在的虚拟环境conda info -econda env list\n\n删除虚拟环境：conda remove -n [env_name] --all\n\n重命名环境\nconda没有直接重命名环境的功能，但可以通过以下两个步骤完成：\n克隆要重命名的环境\n将原环境删除\n\n\n\nconda create --name [newname] --clone [oldname]conda remove --name [oldname] --all\n\n\n\n包管理安装包conda install [pac_name]=[包的版本号]\n\n查看已经安装的包\n查看当前环境：\n\nconda list\n\n\n查看指定环境：\n\nconda list -n [env_name]\n\n删除包conda uninstall [pac_name]\n\n更新指定包conda update [pac_name]\n\n清理包\n通过以下指令来删除一些没用的包，这个命令会检查哪些包没有在包缓存中被硬依赖到其他地方，并删除它们\n\nconda clean -p\n\n\n删除conda保存下来的tar包\n\nconda clean -t\n\n\n删除所有的安装包及cache\n\nconda clean -y --all\n\n更新condaconda update conda\n\n安装requirements.txt文件内的包\n首先通过cd指令进入requirements.txt文件所在路径，然后执行如下指令即可\n\npip install -r requirements.txt\n\n包的数据源管理\n显示目前conda的数据源有哪些：\n\nconda config --show channels\n\n\n添加数据源：(清华源)\n\nconda config --add https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\n\n\n删除数据源\n\nconda config --remove channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\n\n","categories":["Tech"],"tags":["python"]},{"title":"YAML","url":"/2024/03/14/YAML%E5%9F%BA%E7%A1%80/","content":"YAMLYAML Ain’t a Markup Language\nYet Another Markup Language\nYAML是”YAML Ain’t a Markup Language”（YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML的意思其实是：”Yet Another Markup Language”（仍是一种标记语言），但为了强调这种语言以数据为中心，而不是以标记语言为重点，而用反向缩略语重命名。YAML (wikipedia.org)\nYAML特点是使用空格来表达层次结构，特别适合用来表达或编辑数据结构、各种配置文件，其文件一般以 .yaml 为后缀。\n基本语法\n以 k: v 的形式来表示键值对的关系\n\n冒号后面必须有一个空格\n\n\n只支持单行注释，注释符号：# \n\n大小写敏感\n\n通过缩进来表示层级关系\n\n缩排中空格的数目不重要，只要相同阶层的元素左侧对齐就可以了\n缩进只能使用空格，不能使用 tab 缩进\n\n\n字符串可以不用双引号\n\n一个文件中可以包含多个文件的内容\n\n用--- 即三个破折号表示一份内容的开始\n用...即三个小数点表示一份内容的结束（非必需）\n\n\n\n数据结构与类型对象以键值对 key: value 形式组织数据\n1. 使用**冒号+空格**来分开键与值\n1. 支持多层嵌套（**用缩进表示层级关系**）\n\nmodel:  base_learning_rate: 4.5e-6  target: ldm.models.autoencoder.AutoencoderKL  params:    monitor: &quot;val/rec_loss&quot;    embed_dim: 64    lossconfig:      target: ldm.modules.losses.LPIPSWithDiscriminator      params:        disc_start: 50001        kl_weight: 0.000001        disc_weight: 0.5\n\n\n支持流式风格（Flow style）的语法：用花括号包裹，用逗号加空格分隔\n\nkey: &#123;child-key1: value1, child-key2: value2 &#125;\n\n\n\n数组\n一组以区块格式（“破折号+空格”）开头的数据组成一个数组\n\nunet_config:  target: ldm.modules.diffusionmodules.openaimodel.UNetModel  params:    image_size: 64    in_channels: 3    out_channels: 3    model_channels: 224    attention_resolutions:    - 8    - 4    - 2    num_res_blocks: 2    channel_mult:    - 1    - 2    - 3    - 4    num_head_channels: 32\n\n\n也支持内联格式来表达（用方括号包裹，逗号加空格分隔）\n\nddconfig:  double_z: True  z_channels: 64  resolution: 256  in_channels: 3  out_ch: 3  ch: 128  ch_mult: [1, 1, 2, 2, 4, 4]    num_res_blocks: 2  attn_resolutions: [16, 8]  dropout: 0.0\n\n\n支持多维数组（用缩进表示层级关系）\n\nvalues:  - - 1    - 2  - - 3    - 4# 等价：    values: [[1, 2], [3, 4]]\n\n\n\n字符串\n字符串一般不需要用引号包裹\n字符串换行视为一个空格\n单引号可以屏蔽转义\n字符串中需要使用转义字符\\就必须使用双引号包裹\n\nstrings:  - Hello world # 不用引号包裹  - Hello     world # 换行视为一个空格  - &#x27;字符串\\n换行\\n演示&#x27;  # 单引号可以屏蔽转义  - &quot;字符串\\n换行\\n演示&quot;  # 双引号使用转移符号# 结果：- Hello world- Hello world- 字符串\\n换行\\n演示- &#x27;字符串  换行  演示&#x27;\n\n\n保留换行：使用竖线符“ | ”来表示该语法，每行的缩进和行尾空白都会被去掉，而额外的缩进会被保留\n\nlines: |  我是第一行  我是第二行    我是吴彦祖      我是第四行  我是第五行  # 结果&quot;我是第一行\\n我是第二行\\n  我是吴彦祖\\n    我是第四行\\n我是第五行\\n&quot;\n\n\n折叠换行：使用右尖括号“ &gt; ”来表示该语法，只有空白行才会被识别为换行，原来的换行符都会被转换成空格\n\nlines: &gt;  我是第一行  我也是第一行  我仍是第一行  我依旧是第一行  我是第二行  这么巧我也是第二行# 结果lines2: &#x27;我是第一行 我也是第一行 我仍是第一行 我依旧是第一行  我是第二行 这么巧我也是第二行  &#x27;\n\n\n\n布尔值\n“true”、“True”、“TRUE”、“yes”、“Yes”和“YES”皆为真\n“false”、“False”、“FALSE”、“no”、“No”和“NO”皆为假\n\n整数\n支持二进制表示\n\nint:  - 666  - 0001_0000# 结果int:- 666- 4096\n\n\n\n浮点数\n支持科学计数法\n\nfloat:  - 3.14  - 6.8523015e+5 # 使用科学计数法# 结果float:- 3.14- 685230.15\n\n空 Nullnull、Null、~ 和不指定值都表示空\nnulls:  - null  - Null  - ~  -# 结果nulls:- null- null- null- null\n\n\n\n强制类型转换双感叹号+目标类型来强制转换类型\na: !!float &#x27;666&#x27; # !! 为严格类型标签b: !!int &#x27;666&#x27;   # 字符串转为整型c: !!str 666     # 整数转为字符串d: !!str 666.66  # 浮点数转为字符串e: !!str true    # 布尔值转为字符串f: !!bool &#x27;yes&#x27;  # 字符串转为布尔值# 结果a: 666.0b: 666c: &#x27;666&#x27;d: &#x27;666.66&#x27;e: &#x27;true&#x27;f: true\n\n\n\n数据复用与合并数据复用在key的冒号后，使用锚点符号&amp;设定锚点，使用引用符号*引用锚点\nmodel: &amp;all_parm  base_learning_rate: 2.0e-06  target: ldm.models.diffusion.ddpm.LatentDiffusion  params: &amp;model_parm    linear_start: 0.0015    linear_end: 0.0195    num_timesteps_cond: 1    log_every_t: 200    timesteps: 1000    first_stage_key: image    image_size: 64    channels: 3    monitor: val/loss_simple_emanew_model: *all_parmnew_params: *model_parm# 结果new_model:  base_learning_rate: 2.0e-06  target: ldm.models.diffusion.ddpm.LatentDiffusion  params:    linear_start: 0.0015    linear_end: 0.0195    num_timesteps_cond: 1    log_every_t: 200    timesteps: 1000    first_stage_key: image    image_size: 64    channels: 3    monitor: val/loss_simple_emanew_params:  linear_start: 0.0015  linear_end: 0.0195  num_timesteps_cond: 1  log_every_t: 200  timesteps: 1000  first_stage_key: image  image_size: 64  channels: 3  monitor: val/loss_simple_ema\n\n\n\n数据合并合并标签符号“&lt;&lt;”配合锚点符号和引用符号使用可以与任意数据进行合并，可以视为面向对象中的继承\nmodel_location: &amp;loc  target: ldm.models.diffusion.ddpm.LatentDiffusionmodel_params: &amp;params  params:    linear_start: 0.0015    linear_end: 0.0195    num_timesteps_cond: 1    log_every_t: 200    timesteps: 1000    first_stage_key: image    image_size: 64    channels: 3    monitor: val/loss_simple_emanew_model:  base_learning_rate: 2.0e-06  &lt;&lt;: *loc  &lt;&lt;: *params  # 结果new_model:  target: ldm.models.diffusion.ddpm.LatentDiffusion  params:    linear_start: 0.0015    linear_end: 0.0195    num_timesteps_cond: 1    log_every_t: 200    timesteps: 1000    first_stage_key: image    image_size: 64    channels: 3    monitor: val/loss_simple_ema  base_learning_rate: 2.0e-06\n\n\n\n参考一文看懂 YAML - 知乎 (zhihu.com)\n","categories":["Tech"],"tags":["python"]},{"title":"Hello World","url":"/2024/02/02/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"AutoPipeline基本教程","url":"/2024/03/09/2.%20Auto%20Pipeline/","content":"AutoPipeline基本教程AutoPipeline 的设计目的是： \n\n轻松加载 checkpoint，而无需知道要使用的特定pipeline的类型 \n在工作流程中使用多个pipeline\n\nAutoPipeline 类旨在简化 Diffusers 中的各种Pipeline。它是一个通用的、任务优先的管道。 AutoPipeline 会自动检测要使用的正确 Pipeline 类，这使得在不知道特定Pipeline类名称的情况下轻松加载任务的检查点\n\nAPI: AutoPipeline (huggingface.co)\n\nDiffusers 能够完成许多不同的任务，并且您通常可以将相同的预训练权重重复用于多个任务，例如文本到图像、图像到图像和修复。如果您对库和扩散模型不熟悉，可能很难知道要使用哪个管道来完成任务。\n为您的任务选择 AutoPipeline首先选择一个检查点。例如，如果想要使用 runwayml&#x2F;stable-diffusion-v1-5 检查点来进行文本到图像（T2I）任务，请使用 AutoPipelineForText2Image：\nfrom diffusers import AutoPipelineForText2Imageimport torch, ospipeline = AutoPipelineForText2Image.from_pretrained(    &quot;sd-v1.5&quot;,                 # 权重路径    torch_dtype=torch.float16, # 数据类型    use_safetensors=True,      # 使用safetensor类型的权重    variant=&#x27;fp16&#x27;,            # 加载权重时选择文件名中带有‘fp16’的).to(&quot;cuda&quot;)prompt = &quot;peasant and dragon combat, wood cutting style, viking era, bevel with rune&quot;image = pipeline(prompt, num_inference_steps=25).images[0]num = len(os.listdir(&#x27;./results&#x27;))image.save(f&#x27;./results/Auto_tur_&#123;num&#125;.png&#x27;)\n\n深入层次探讨 AutoPipelineForText2Image \n\nAutoPipeline将自动从 model_index.json 文件中检测 StableDiffusionPipeline 类\n根据类名加载相应的文本到图像的StableDiffusionPipeline\n\nmodel_index.json文件内容：\n&#123;  &quot;_class_name&quot;: &quot;StableDiffusionPipeline&quot;,  &quot;_diffusers_version&quot;: &quot;0.6.0&quot;,  &quot;feature_extractor&quot;: [    &quot;transformers&quot;,    &quot;CLIPImageProcessor&quot;  ],  &quot;safety_checker&quot;: [    &quot;stable_diffusion&quot;,    &quot;StableDiffusionSafetyChecker&quot;  ],  &quot;scheduler&quot;: [    &quot;diffusers&quot;,    &quot;PNDMScheduler&quot;  ],  &quot;text_encoder&quot;: [    &quot;transformers&quot;,    &quot;CLIPTextModel&quot;  ],  &quot;tokenizer&quot;: [    &quot;transformers&quot;,    &quot;CLIPTokenizer&quot;  ],  &quot;unet&quot;: [    &quot;diffusers&quot;,    &quot;UNet2DConditionModel&quot;  ],  &quot;vae&quot;: [    &quot;diffusers&quot;,    &quot;AutoencoderKL&quot;  ]&#125;\n\n\n\n同样，对于图像到图像任务的AutoPipeline，AutoPipelineForImage2Image 从 model_index.json 文件中检测到 “StableDiffusion” 检查点，并将在幕后加载相应的 StableDiffusionImg2ImgPipeline。\n还可以传递特定于 Pipeline 类的任何其他参数，如guidance_scale、strength\nimport osos.environ[&#x27;HTTP_PROXY&#x27;] = &#x27;http://127.0.0.1:33210&#x27;os.environ[&#x27;HTTPS_PROXY&#x27;] = &#x27;http://127.0.0.1:33210&#x27;from diffusers import AutoPipelineForImage2Imageimport torchimport requestsfrom PIL import Imagefrom io import BytesIOpipeline = AutoPipelineForImage2Image.from_pretrained(    &quot;sd-v1.5&quot;,    torch_dtype=torch.float16,    use_safetensors=True,    variant=&#x27;fp16&#x27;,).to(&quot;cuda&quot;)prompt = &quot;a portrait of a dog wearing a pearl earring&quot;url = &quot;https://upload.wikimedia.org/wikipedia/commons/thumb/0/0f/1665_Girl_with_a_Pearl_Earring.jpg/800px-1665_Girl_with_a_Pearl_Earring.jpg&quot;response = requests.get(url)image = Image.open(BytesIO(response.content)).convert(&quot;RGB&quot;)image.thumbnail((768, 768))image = pipeline(prompt, image, num_inference_steps=200, strength=0.75, guidance_scale=10.5).images[0]num = len(os.listdir(&#x27;./results&#x27;))image.save(f&#x27;./results/Auto_tur2_&#123;num&#125;.png&#x27;)\n\n\n\n如果您想进行图像修复，则 AutoPipelineForInpainting 以相同的方式加载底层的 StableDiffusionInpaintPipeline 类：\nimport osos.environ[&#x27;HTTP_PROXY&#x27;] = &#x27;http://127.0.0.1:33210&#x27;os.environ[&#x27;HTTPS_PROXY&#x27;] = &#x27;http://127.0.0.1:33210&#x27;from diffusers import AutoPipelineForInpaintingfrom diffusers.utils import load_imageimport torchpipeline = AutoPipelineForInpainting.from_pretrained(    r&quot;D:\\MyCode\\Torch_Deom\\SDXL\\stable-diffusion-xl-base-1.0&quot;,     torch_dtype=torch.float16,     use_safetensors=True,     variant=&#x27;fp16&#x27;,).to(&quot;cuda&quot;)img_url = &quot;https://raw.githubusercontent.com/CompVis/latent-diffusion/main/data/inpainting_examples/overture-creations-5sI6fQgYIuo.png&quot;mask_url = &quot;https://raw.githubusercontent.com/CompVis/latent-diffusion/main/data/inpainting_examples/overture-creations-5sI6fQgYIuo_mask.png&quot;init_image = load_image(img_url).convert(&quot;RGB&quot;)mask_image = load_image(mask_url).convert(&quot;RGB&quot;)prompt = &quot;A majestic tiger sitting on a bench&quot;image = pipeline(prompt, image=init_image, mask_image=mask_image, num_inference_steps=50, strength=0.80).images[0]num = len(os.listdir(&#x27;./results&#x27;))image.save(f&#x27;./results/Auto_tur3_&#123;num&#125;.png&#x27;)\n\n如果您尝试加载不受支持的检查点，则会抛出错误\n使用多个Pipeline对于某些工作流程或如果您要加载许多Pipeline，从检查点重用相同的组件会更节省内存。例如，如果您正在使用文本到图像任务的检查点，并且想要再次将其用于图像到图像任务，请使用 from_pipe() 方法。此方法从先前加载的Pipeline的组件创建新Pipeline，无需额外的内存成本。\nfrom diffusers import AutoPipelineForText2Image, AutoPipelineForImage2Imageimport torchpipeline_text2img = AutoPipelineForText2Image.from_pretrained(    &quot;sd-v1.5&quot;,     torch_dtype=torch.float16,     use_safetensors=True,     variant=&#x27;fp16&#x27;,)print(type(pipeline_text2img))# &quot;&lt;class &#x27;diffusers.pipelines.stable_diffusion.pipeline_stable_diffusion.StableDiffusionPipeline&#x27;&gt;&quot;\n\n然后 from_pipe() 将原始的 StableDiffusionInpaintPipeline 类映射到 StableDiffusionImg2ImgPipeline：\npipeline_img2img = AutoPipelineForImage2Image.from_pipe(pipeline_text2img)print(type(pipeline_img2img))# &quot;&lt;class &#x27;diffusers.pipelines.stable_diffusion.pipeline_stable_diffusion_img2img.StableDiffusionImg2ImgPipeline&#x27;&gt;&quot;\n\n\n\n如果您将可选参数（例如禁用安全检查器）传递给原始 Pipeline，则该参数也会传递给新管道：\npipeline_text2img = AutoPipelineForText2Image.from_pretrained(    &quot;sd-v1.5&quot;,    torch_dtype=torch.float16,    use_safetensors=True,    requires_safety_checker=False,    variant=&#x27;fp16&#x27;).to(&quot;cuda&quot;)pipeline_img2img = AutoPipelineForImage2Image.from_pipe(pipeline_text2img)print(pipeline_img2img.config.requires_safety_checker)&quot;False&quot;\n\n如果您想更改新管道的行为，您可以覆盖原始管道中的任何参数甚至配置。例如，要重新打开安全检查器并添加强度参数：\npipeline_img2img = AutoPipelineForImage2Image.from_pipe(    pipeline_text2img,     requires_safety_checker=True,     strength=0.3)print(pipeline_img2img.config.requires_safety_checker)&quot;True&quot;\n\n\nNextAPI: AutoPipeline (huggingface.co)\n","categories":["Research"],"tags":["diffusers","AIGC"]},{"title":"PPT注意事项","url":"/2023/12/25/ppt%E5%88%B6%E4%BD%9C/","content":"PPT注意事项\n无衬线字体\n英文首字母大写即可\n常规内容：18-36字号，底部和引用字号&lt;12\n空白简单背景\n徽标不要在内容页出现，用于首页、过渡页、尾页\n避免高饱和颜色的撞色，黑白永不过时\n给页面留白：侧面留出空间，底部不要放太多内容\n标题：每页都要有标题，一个简单句、不要超过两行\n不能出现大段文字\n单页不能有过多内容，独立内容放在不同页，避免失去焦点\n同一页列表不要超过3个条目\n图表的全部要素都要解释清楚\n考虑不同时间限制的情况下内容的安排\n动画：少就是多，简单为主。用来表达递进、放大、进一步、变化等逻辑\n页面切换：平滑\n总结：强调重要内容，增加页面的总结和页面之间的串联讲解，让听众明白当前的演讲处于什么阶段\n\n基本原则\n始终考虑听众如何更容易的接受内容\n不打算聊的内容删除\n好的演讲始于一个好问题\n一页中保持一个内容\n\n","categories":["Note"]}]